# Next js full auth related document

## Index
- Creating a next project
- Run the project and text tailwind
- Creating register, login folder and page
- Creating .env file
- Creating mongodb connection
- Making mongoose schema
- Creating api route for registering user
- Making registration page functional
- Installing next auth
- Google oAuth setup
- Github oAuth setup
- Using middleware function to protect route
- Creating session provider
- Getting user info in the server component
- Getting user info in the client component
- Image config in next.js

- Creating the auth route
- Installing shadcn/ui
- Adding shadcn-ui button component
- Detail about app router
- Using callback function to apply role based authentication
- Github oAuth setup
- Email verification for credential users
- Next js smooth image load

### Creating a next project
- Open VS code and open terminal and write following code and press enter
```javascript
npx create-next-app@latest your-project-name
```
- Select from necessary question.
- Open the project.

### Run the project and text tailwind

- Go to the terminal and write
```javascript
npm run dev
```
- Go to the app folder and open page.js/page.ts and delete everything inside the return statement and write something also style with tailwind class. Check whether they are reflecting in the ui.


### Creating register, login folder and page

- Usually register and login page doesn't have navbar. So it should kept separate from main layout. Otherwise is navbar is placed in the main layout page it will be displayed register and login page also. 

- In order to do it inside the app folder create a folder name (login). You can name it anything but make sure to keep the name inside (). 

- Inside the (login) folder create two folder named 'login' and 'register' and inside each folder create page.jsx/page.tsx file. 

- In order to make your code clean make two component 'RegisterForm.jsx' and 'LoginForm.jsx' in your component folder. 

- Design the registration and login form inside the component and import the component in the register and login page. 

- We will add interactivity in the register and login form later. 


### Creating .env file

- In the root of your project create and .env file

- Paste the following code inside it
```javascript
MONGO_URL=
NEXTAUTH_URL=https://auth-testing-mu.vercel.app/
NEXTAUTH_SECRET=afkdjnk2234lkajflsafjejinflk233443
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=
```
- In the MONGO_URL you will put mongodb connection string along with database user name and database user password and the database name. Your code will look like as follows
```javascript
MONGO_URL=mongodb+srv://tech-army:54AQ4FhQeXsj8cbL@cluster0.ktgpsav.mongodb.net/tech-armyDb?retryWrites=true&w=majority
```
- In the string DB_USER is tech-army, DB_PASSWORD is 54AQ4FhQeXsj8cbL and database name is tech-armyDb. You should put your own.

- NEXTAUTH_URL should be http://localhost:3000 for development and your website url for production. In the above case production url is used. 

- NEXTAUTH_SECRET should be generated by you. In order to create a secure one you should open your terminal and type
```javascript
openssl rand -base64 32
```
- It will provide you a random key. You can paste it here. 

- If you use jwt as session strategy the with secret it will not work. 


### Creating mongodb connection

- Open the terminal and install following
```javascript
npm i mongodb mongoose
```
- Make a folder parallel to the app folder and name it utils. Inside it create a file name 'dbConnect.js'. You can name it anything you want. 

- Inside the file paste the following code to make mongodb connection.

```javascript 
import mongoose from 'mongoose'

const connect = async () => {
    try {
    await mongoose.connect(process.env.MONGO_URL)
      console.log("Mongo connection successfully established.")
  } catch(error){
    throw new Error (
      "Error connecting to Mongoose")
  }
}

export default connect;
```
- Make sure in the .env file your paste mongodb connection. Otherwise it will not work. 

### Making mongoose schema

- You need model/schema for the data you want to store in the database. As we will store user data in the database so we will only create User model. For storing other type of data you have to create model for them as well. 

- Parallel to app folder create a folder named models and inside it create a file named User.js

- Paste the following code inside it.

```javascript
import mongoose, { models } from "mongoose"

const {Schema} = mongoose;

const userSchema = new Schema(
  { 
    name:{
    type: String,
    required:true,
  },
    email:{
      type: String,
      unique: true,
      required: true, 
    },
    password: {
      type: String,
      required: false,
    },
  },
  {timestamps: true}
)


const User = models.User || mongoose.model("User", userSchema)
export default User
```
- We will have three input name, email, password. If you have more than that you can add additional data field in the model. 

- Our user may login using google so we kept password field optional. 

- Timestamps will record automatically the time when the user was created and when it is updated. You may omit it if you want. 

- Exporting user will allow us the model at the time of api call. 

### Creating api route for registering user

- Inside the app folder create a folder named api and inside that create another folder named register. This will create a new route '/api/register'. We will call this route for registering our user. 

- Install bcrypt as follows

```javascript
npm i bcrypt
```
- It will be used to hash password. We will not keep plain password in the database. We will hash it and the save it in the database. And bcrypt will be used for hashing. 

- Inside the register folder create a file name route.js/route.ts. Paste the following code inside it. 

```javascript
import User from "@/models/User"
import connect from "@/utils/mongodbConnect"
import bcrypt from "bcrypt"
import { NextResponse } from "next/server"


export const POST = async (req) => {
  try {
    const {email, password, name} = await req.json()
    console.log(email, password, name)
    await connect()

    const existingUser = await User.findOne({email})

    if(existingUser){
      return new NextResponse("Email is already in use", {status: 400})
    }

  const hashedPassword = await bcrypt.hash(password, 10)
  
    const newUser = new User({
      name, email,
      password: hashedPassword
    })

    try {
      await newUser.save()
      return new NextResponse("User successfully created", {status: 200})
    } catch (error) {
      console.log(error)
      return new NextResponse(error, {status: 500})
    }

  } catch (error) {
    console.log(error)
    return new NextResponse("Internal Server Error", {status: 500})
  }
}
```

- We imported User model that we created earlier. We also imported connect function that connected the mongodb. Bcrypt is imported to hash password and we imported NextResponse from next server so that we can send message to the front end. 

- As we want to register user so there will be a post request from the frontend, so we created an asynchronous POST function. The function takes a req parameter that will hold data from the frontend. 

- Inside the try block we destructure the req.json() object and collect email, password and name field from it. If you send more data you can destructure it as like it. 

- Then we connected with the mongodb by calling connect function. 

- Then we checked whether user is already exist. User.findOne is a query of mongoose. It takes user model and findOne data in the database and query is based on email property in the database. If user email sent from the front end is matched with the email field of any document in the mongodb then it will be stored in the existingUser variable. 

- If email is exist in database that means user is already registered, so we will response the frontend that this email is exist. 

- If email does not exist that means the user is new user so we have to save his information in the database. 

- hashedPassword variable used bcrypt to hash user password. 

- Then a new object is created where name and email from frontend it kept but in the password field instead of raw password the hashed password is kept. 

- The newUser.save() function save the newUser object in  the database. 

- Then once the data saved successfully response is sent to the frontend with status 200 and "User successfully created" message. 

- If there is any error in user creation then catch block will catch it and send to the frontend. 

- Another catch block is in place to catch error in post operation and will send message accordingly. 

### Making registration page functional 

- Go to the RegisterForm component. As there will interaction in this component so it should be a client component. Write 'use client' at the top of the component. 

- The code will be like as follows

```javascript
'use client'

import { useRouter } from "next/navigation"

const RegisterForm = () => {
  const router = useRouter()
  
  const handleSubmit = async(e) => {
    e.preventDefault()
    const name = e.target.name.value
    const email = e.target.email.value
    const password = e.target.password.value
    
    try{
      const res = await fetch("/api/register", {
        method: "POST",
        headers:{
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          email, password, name
        })
      })

      if (res.status === 400){
        console.log('This email is already registered')
      }
      if(res.status === 200){
        console.log('Registration successful')
        router.push('/login')
      }
    } catch(error){
      console.log(error)
    }
  }


  return (
    <form onSubmit={handleSubmit}
    className="flex justify-start items-start flex-col w-1/2 mx-auto gap-3 border border-green-400 p-5 shadow-2xl"
    >
      <div className="space-y-3">
        <label htmlFor="name">Name</label>
        <input 
        type='text'
        name="name"
        className='w-full p-2 border shadow-xl '
        placeholder='Name'
        />
      </div>
      <div className="space-y-3">
        <label htmlFor="email">Email</label>
        <input 
        type='email'
        name="email"
        className='w-full p-2 border shadow-xl '
        placeholder='Email'
        />
      </div>
      <div className="space-y-3">
        <label htmlFor="password">Password</label>
        <input 
        type='password'
        name="password"
        className='w-full p-2 border shadow-xl '
        placeholder='Password'
        />
      </div>
      <div className="flex items-center justify-center my-4">
      <input type="submit" value="Register"
      
      className="py-2 px-4 bg-slate-500 rounded-lg "/>
      </div>
    </form>
    
  )
}

export default RegisterForm
```
- useRouter hook is imported to redirect the user to another page after registration. Make sure it is imported from next/navigation not next/router. 

- Inside the RegisterForm function useRouter is called and kept in router variable. 

- handleSubmit is an asynchronous function that wil be activated on the submit of form. It will take the value of input field. 

- The try block will use fetch function to call '/api/register' route and post data in json format. 

- In the example if it receive successful response then it console log 'Registration successful'. In your case you should show a toast or notification.

- If response is successful then router.push('/login/) is redirect the user to the login page. 

- Catch block will catch any error in the fetch process and you should show error using toast or notification. 

### Creating the auth route

- - Next auth has two site. The old site address is next-auth.js.org and it host upto version 4 documentation. And they has migrated to a new site which address is authjs.dev and it host the latest v5. Here we will use v4 so will use the old site information. 

- Inside tha api folder create a folder name 'auth' and inside the 'auth' folder create another folder name '[...nextauth]' and inside the folder create a file name route.js/route.ts. If you change the file or folder name it will not work. Inside this file we will write all authentication related code. Some people create two file inside '[...nextauth]' folder. One is route.js/route.ts and another is option.js/option.ts. All code is written in the option.js/option.ts file and route.js/route.ts is used to export it. 

- Install next auth using following command in the terminal

```javascript
npm install next-auth
```

- Paste the following code inside route.js/route.ts file

```javascript
import User from "@/models/User"
import connect from "@/utils/mongodbConnect"
import CredentialsProvider from "next-auth/providers/credentials"
import NextAuth from "next-auth/next";
import GoogleProvider from 'next-auth/providers/google'


export const authOptions = {
  providers:[
    GoogleProvider({
      clientId:process.env.GOOGLE_CLIENT_ID,
      clientSecret:process.env.GOOGLE_CLIENT_SECRET,
    }),
    CredentialsProvider({
      name: "credentials", 
      credentials: {},
      async authorize(credentials){
        const { email, password } = credentials
        try {
          await connect()
          const user = await User.findOne({email})

          if(!user){
            return null
          }

          const passwordsMatch = await bcrypt.compare(password, user.password);
          
          
          if (!passwordsMatch) {
            return null;
          }

          return user;

        } catch (error) {
          console.log(error)
        }

      }
    })
  ],
  callbacks: {
    async signIn({user, account}){
      if(account.provider === 'google'){
        const {name, email} = user
        try {
          await connect()
          const userExist = await User.findOne({email})
       
          if(!userExist){
            const res = await fetch('https://auth-testing-mu.vercel.app/api/register', {
              method:"POST",
              headers: {
                "Content-Type": 'application/json'
              },
              body: JSON.stringify({
                name, email, 
               
              })
            })
            if(res.ok){
              return user;
            }
          }

          return user
        
        } catch (error) {
        console.log(error)   
        }
       
      }
      if(account.provider === 'credentials'){
        return user
      }
    },
    async jwt({token, user}){
    
       return token
    }, 
    async session({session, token}){
      
          session.user.name = token.name
          session.user.email = token.email
      return session
    }
  },
  session: {
    strategy: "jwt"
  },
  secret: process.env.NEXTAUTH_SECRET,
  pages:{
    signIn: "/login"
  }
}

const handler = NextAuth(authOptions)

export {handler as GET, handler as POST}
```

- Let's start with explanation. 

- In the import User is the mongoose model getting or posting data from and to the database. connect is imported to make connection with mongodb. CredentialsProvider is imported to signin using email and password. GoogleProvider is imported to signin using google. NextAuth is imported for authentication. 

- The authOptions object will contains all the code related to authentication. Make sure to export it. It will be used in the server component to access user data. If you do not export it then the user data cannot be accessed from the server. 

- providers array contains code related to email, google or github sign in. 

- GoogleProvider hold information about clientId and clientSecret and other information. This is a simple code so we have only the id and secret. How to get id and secret will be discussed later. 

- GithubProvider could also be set if you want. The process is same as GoogleProvider. How to get github id and secret will be discussed later. 

- CredentialsProvider hold codes related to email login. 

- In the name property you can give any name. 

- Next-auth provide a default signin page. What could be the label and input field of the default signin page is defined inside the credentials object. We designed a custom signin page so we kept it empty object. 

- The authorize function takes credentials as a parameter. The credentials will hold the email and password from the login page. 

- We destructure the credential object to email and password. 

- connect() function connect with mongodb.

- Based on email received from frontend we start a find operation in the user collection and if any result found it is stored in the user object. 

- If no user is found then we return null to the frontend. 

- If user found we will compare user password from database with credentials password and put the result in the passwordMatch variable. 

- If password doesn't match we will return null.

- If password match then we will return user. 

- Catch block will catch any error in the process and should send to the frontend as a response. 

- The callbacks property hold an object and in our example it hold three async function.

- First async function is signIn which takes user and account as parameter. 

- First it check if user logged in using google. If yes it destructure the user and take out name and email. It then connect to the mongodb and search the user collection and check whether any user exist with this email. If no user exist we save user info in the database. Here at the time of api call if you user '/api/register' it will not work. You have to give full site link. At development you will use localhost and at production make sure to change it with live site link. If data is saved properly return user. If user already exist in the database then also return user. The catch block catch any error in database operation. 

- Secondly it check whether user logged in using email. If yes it simply return the user because the database operation is done in the authorize function already. 

- Second asynchronous function is jwt. In our example it simply return the token. We will use the information inside token later in the session function. 

- Third asynchronous function is session. It takes session and token as parameter. We take user name and email from token and set it inside session. If you have image or other info you can set it here. If user login using google then the google image link is automatically saved inside the session. Then we return the session so that it can be used in the frontend. 

- The session property set the session strategy and it is jwt. 
- Next property is secret. When we set session strategy as jwt we must have to provide secret otherwise auth will not work. 

- The pages property indicate our signIn page will be found in '/login' route and this the where our custom login page is located. 

- Then we created a handler variable and called NextAuth function and pass the authOptions as a parameter of it. 

- At last we export the handler an GET and POST so that we can use it later. 


### Google oAuth setup

- Go to the .env file and write GOOGLE_CLIENT_ID= & GOOGLE_CLIENT_SECRET= 

- Go to browser and type console.cloud.google.com, click link, at the top click the Select a project dropdown menu, click on NEW PROJECT button, in the Project Name input field write the project name and click CREATE button. After the creation of project, select the project. Click the search button and type api & services and click it. On the left side bar click OAuth concent screen and select External radio button and click CREATE button. In the app name field write the app name and in the User support email select your email. in the Developer contact information section in the input field write the email address and click Save and continue button. In the next page also click save and continue button. In the next page also click save and continue button. Now at the left side bar click Credentials. Click CREATE CREDENTIALS button. Then click OAuth client ID. In the Application type input field select Web Application. In the Authorized JavaScript origins write http://localhost:3000 (make sure to replace it with live site link when you use the live site)and in the Authorized redirect URIs write http://localhost:3000/api/auth/callback/google (make sure to replace the localhost with live site link). Click CREATE button. In a modal you will see client ID and Client secret. Copy them and paste in the .env file. 


### Github oAuth setup

- Go to the .env file and write GITHUB_CLIENT_ID= & GITHUB_CLIENT_SECRET= 
- Go to github, click the profile icon, in the side bar click settings, on the left nav bar at the bottom click Developer settings, on the left side bar click OAuth Apps, On the right side click New OAuth App button, write the application name, in the Homepage URL input field write http://localhost:3000 (make sure to replace it with live site link when you use the live site) and don't write / after 3000. In the Authorization callback URL input field write http://localhost:3000/api/auth/callback/github (make sure to replace the localhost with live site link), then click Register application button. You will get client id there, copy it and paste it in the .env file. Then click Generate a new client secret button, copy the secret and paste it in .env file. 

### Making login page functional 

- Go to the LoginForm component and paste following code

```javascript
'use client'

import { signIn, useSession } from "next-auth/react"
import { useRouter } from "next/navigation"

const LoginForm = () => {
    const router = useRouter()
  
  const handleSubmit = async(e)=> {

    e.preventDefault()
    const email = e.target.email.value
    const password = e.target.password.value

    const res = await signIn("credentials", {
      redirect: false, 
      email,
      password
    })

    if(res.error){
      console.log('Invalid credentials')
    }
    
    router.push('/client')
    console.log('login successful')

  }
  return (
    <div>
      <form onSubmit={handleSubmit}
    className="flex justify-start items-start flex-col w-1/2 mx-auto gap-3 border border-green-400 p-5 shadow-2xl"
    >
      <div className="space-y-3">
        <label htmlFor="email">Email</label>
        <input 
        type='email'
        name="email"
        className='w-full p-2 border shadow-xl '
        placeholder='Email'
        />
      </div>
      <div className="space-y-3">
        <label htmlFor="password">Password</label>
        <input 
        type='password'
        name="password"
        className='w-full p-2 border shadow-xl '
        placeholder='Password'
        />
      </div>
      <div className="flex items-center justify-center my-4">
      <input type="submit" value="Login"
      
      className="py-2 px-4 bg-slate-500 rounded-lg "/>
      </div>
    </form>
    <div className="flex justify-center items-center">
    <button className="mt-5 text-center py-2 px-4 rounded-lg bg-slate-500 text-white"
    onClick={() => signIn('google')}
    >Sign in With Google</button>
    </div>
    </div>
    
  )
}

export default LoginForm
```

- As there will be interaction here so by writing 'use client' at the top we make it a client component. 

- We imported signIn from next-auth and useRouter from next navigation to redirect user after login. 

- We called the useRouter hook and kept it inside router variable. 

- handleSubmit function is an onSubmit handler. When login form is submitted by the user handleSubmit function call api an do some functionality. It is an asynchronous function. It collect login form data. In our case there is two field email and password. Is called signIn from next auth and pass the credentials to make it understand that this is email login and pass an object. In the object it pass email and password field received from login form and also make redirect false so that page does not reload. If any error received from server it is console logged in our case. Your should show a toast or alert. 

- If login successful we redirect the user to the '/client' route. Your can redirect any route as you wish. Also you should show a toast or alert here. 

- Inside the return you should design you page as you want.

- At the bottom of the page there is a button named "Sign in With Google". It is used for google signIn. We passed an onClick function here. It called signIn from next-auth and passed 'google' as a parameter so the auth will understand it is google signin and handle it accordingly. 


### Using middleware function to protect route

- At the root of your project create a file name middleware.js/middleware.ts. You cannot change the name. 

- Paste the following code in it.

```javascript
import { NextResponse } from "next/server";


export function middleware(request){
  const path = request.nextUrl.pathname;
  
  const isPublicPath = path === "/login" || path === "/register"
  
  const token = request.cookies.get('__Secure-next-auth.session-token')?.value || ''

  if(isPublicPath && token){
    return NextResponse.redirect(new URL('/client', request.nextUrl))
  }
  
  if(!isPublicPath && !token){
    return NextResponse.redirect(new URL('/login', request.nextUrl))
  }
}

export const config = {matcher: ["/client/:path*", "/register", "/login"]}
```

- We imported NextResponse from next/server to send response. 

- Next is a custom middleware function that takes request parameter. Don't change request name. 

- path variable collect pathname from nextUrl which is inside request. So you can track in which route the user is located. 

- Then we create a variable which name is isPublicPath and if path = '/login' or '/register' then it store it. 

- Then we collect session token from cookies. If you use live link then the cookie name will be "__Secure-next-auth.session-token". But if you use localhost then its name will be 'next-auth.session-token'. So change the name accordingly otherwise you will get error.

- Then we check if user is in public path (that means either in login or register page) and has token. If he has token that means he is logged in so he should not go to the login or register page. So we redirect him to the client route. You can redirect anywhere you want. 

- Then we check if user in not in public route and does not have token then we redirect him to login page. If you do not do it you can omit the logic. 

- At last we have matcher that has an array of path. The middleware function will work on those path mention in the matcher array. No that we did not mention home route in the matcher array so you can you to the home route without login. But you cannot go to the client route and any route nested inside it without login. If you stay any of these route any press logout button you will be redirected to login page automatically. 

### Creating session provider

- In order to access the user info we have to wrap the whole application by a session provider. It will act like a authProvider in react. 

- Parallel to app folder create a folder named Provider. Inside it create a file name "SessionProvider.jsx" and paste the following code. 

```javascript
"use client"

import { SessionProvider } from "next-auth/react";


const AuthProvider = ({children}) => {
  return <SessionProvider>{children}</SessionProvider>
}

export default AuthProvider;
```
- Session provider must be a client component so we wrote "use client" at the top of the component to make it client component. 
- Then we imported SessionProvider from next-auth.

- Then we created a function named AuthProvider and passed children as parameter. You can change the function name to anything you want.

- AuthProvider function return SessionProvider tag that hold children inside it. 

- Next task is to wrap the whole project by the session provider. Inside the app folder there is a layout.js/layout.ts file which hold the whole project. 

- Go to the file and paste the following code
```javascript
import { Inter } from "next/font/google";
import "./globals.css";
import AuthProvider from "@/Provider/SessionProvider";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body className={inter.className}>
      <AuthProvider>{children}</AuthProvider>

      </body>
    </html>
  );
}

```
- I imported AuthProvider component.

- Inside the body tag i wrapped the children by AuthProvider.

### Getting user info in the server component

- getServerSession function from next-auth is used to get data from authOptions.

- In our example Login page is a server page. So check the following code 

```javascript
import LoginForm from '@/app/_components/LoginForm'
import { authOptions } from '@/app/api/auth/[...nextauth]/route'
import { getServerSession } from 'next-auth'


const Login = async() => {
  const session = await getServerSession(authOptions)

  return (
    <div>
      <h1 className='text-center text-2xl font-bold my-5'>Login</h1>
      <LoginForm/>
    </div>
  )
}

export default Login
```

- Here authOption is imported from auth api route to get session data. getServerSession is imported from next-auth to get session data.

- The Login function is converted to async as we will interact with server. 

- We call the getServerSession function and passed authOptions as a parameter of it and hold the value inside session variable. 

- Now you can use the data inside session as you wish. In our case we didn't use it for any task. 


### Getting user info in the client component

- Check the following code

```javascript
'use client'

import { useSession } from "next-auth/react"
import Image from "next/image"
import LogoutButton from "../_components/LogoutButton"

const ClientPage = () => {
  const session = useSession()
  console.log(session)

  if(session?.status === 'loading'){
    return <p>loading....</p>
  }
  return (
    <div>
 <LogoutButton text={'Logout'}/>

      <p>Name {session?.data?.user?.name}</p>
      <p>Email {session?.data?.user?.email}</p>
      {
        session?.data?.user?.image && (
          <Image src={session?.data?.user?.image} alt="user image" height={500} width={500}
          className="h-20 w-20 rounded-full"
          />
        )
      }

    </div>
  )
}

export default ClientPage
```
- We use 'use client' at the top of the component to make it client component. 

- useSession hook is imported from next-auth

- useSession hook is called inside ClientPage function and store inside session variable. 

- session has status that value range from loading, unauthenticated to authenticated. Here if the status is loading then it return a p tag. 

- Inside the return two p tag extract user name and email from session.data.user and display in the ui. 

- There is a conditional statement where if session.data.user has an image then a Image tag is show the image. 

### Image config in next.js

- In order to show image in next.js using a link we have to put the domain name in the next.config.mjs file which is located at the root of the project. Check the following code

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  images:{
    domains: ['lh3.googleusercontent.com']
  }
};

export default nextConfig;

```
- We added images property. Inside it we added domains property that's value is an array and inside it we put the domain name as string. We can add multiple domain name using , separator. 



###
### Installing shadcn/ui

- It will give us reusable component that we will copy and paste.
- Go to the following link https://ui.shadcn.com/docs/installation and select Next.js from there.
- Alternatively you can run following command in the terminal 
```javascript
npx shadcn-ui@latest init
```
- Answer the questions. 

Would you like to use TypeScript (recommended)? no / yes
Which style would you like to use? › Default
Which color would you like to use as base color? › Slate
Where is your global CSS file? › › app/globals.css
Do you want to use CSS variables for colors? › no / yes
Are you using a custom tailwind prefix eg. tw-? (Leave blank if not) ...
Where is your tailwind.config.js located? › tailwind.config.js (IF YOU USE TYPESCRIPT THEN CLICK TAB AND MAKE THE EXTENTION TO .ts)
Configure the import alias for components: › @/components
Configure the import alias for utils: › @/lib/utils
Are you using React Server Components? › no / yes

- After installation you will see a lib folder and inside it a utils.ts file which have cn function that will be used to dynamically add classed.



### Adding shadcn-ui button component

- Go to https://ui.shadcn.com/docs and find out button component. 
- Copy the code from CLI or copy from below
```javascript
npx shadcn-ui@latest add button
```
- Paste the code to the terminal and press enter. 
- After installation you will see inside the component folder there is a ui folder and inside it there is button.jsx or button.tsx
- We will use the button inside the home page. So go to the page.jsx/page.tsx and import following
```javascript
import { Button } from "@/components/ui/button"
```
- Inside the return statement where you want to use the button write following:
```javascript
<Button>Click Me</Button>
```
- Instead of click me you can write any text you want. 
- If you want to change the button looks you can do it by writing props inside the opening tag.
```javascript
<Button size="lg" variant="outline">Click Me</Button>
```
- You can also create custom props if you wish. In order to do it you have go to the components folder then ui folder then button components. For example you want to create a custom variants. You should go to the variant object and create a new property after link property and write the tailwind class as value. After that you go to the button where you used it. In our case it it home page. now in the variant props you will see the suggestion of your newly created props. 


### Detail about app router


- Inside the app folder the first page represented the root page which we will find in the localhost:3000/ link. So if you want to modify that screen you have to write in that file.

- In order to create a new route we have to create a new folder inside the app folder and inside that folder we have create a file name page.jsx/page.tsx. The new folder name will will be new path. e.g. if you name the new folder as login then //http:localhost:3000/login route will be created in ui. If we write code in the page.jsx/page.tsx inside the login folder we will see the result in the //http:localhost:3000/login link.

- Inside the page.jsx/page.tsx you must create a function and must export default the function. If you only export it then the page will not be shown in the ui. 

- In order to create nested route you have to create folder inside folder and inside each folder there should be a page.jsx/page.tsx file with export default function. e.g. app -> dashboard -> Profile will be displayed in the ui as //http:localhost:3000/dashboard/profile.

- The file name must be page.jsx/page.tsx but inside the file the function name could be anything. In our above example the dashboard folder page.tsx function name could be DashboardPage and profile folder page.tsx function name could be Profile.  

- There is another file inside app folder which is called layout.jsx/layout.tsx. This is act as like mainLayout of react app. It is used to show the children. The layout.jsx inside the app folder is root layout that render the whole website. If you pass any props using by wrapping the component by sessionProvider/authProvider then that props can be received anywhere in the app. 

- We can use multiple layout.jsx file in a project. For example if we want to show different layout in dashboard route then we can create layout.jsx/layout.tsx file inside dashboard folder. And inside the layout.jsx/layout.tsx file we will render children props. We can put common components like navbar, footer etc in this page which will be shared by all the pages inside the dashboard folder. 

- loading file, not found, error. (I WILL WRITE ABOUT IT LATER IN SHA ALLAH)

- If you want to create a shared layout but don't want to create a route then you should keep the folder name inside (). So if you create following folder app -> auth -> login then your login route will be http//localhost:3000/auth/login. But if we want http//localhost:3000/login 
route at the same time keep the auth folder we can write the folder structure as follow:
app -> (app) -> login

- If _ is written before a folder name then the folder will not appear in the route even though page.jsx/page.tsx file is kept inside it.

- Server Component: Any page inside the app folder is by default server component. We can make a server component asynchronous function. They are not for interactivity. We cannot use useEffect, useState, onClick etc in server component.

- Client Component: As we know any page inside the app folder is server component. If we want to convert any component to client component then we have to write "use client" at the top of the page and it will make the component a normal react component. Client component is used for interactivity. So in the client component we can use onSubmit, onClick, useState, useEffect etc. 

### Installing next auth

- Next auth has two site. The old site address is next-auth.js.org and it host upto version 4 documentation. And they has migrated to a new site which address is authjs.dev and it host the latest v5. In the new site go to the guide section and at the bottom you will see Upgrade Guide (v5). 

- Copy the installation code from it.
```javascript
npm install next-auth@beta
```
- In the root of application create a page named with auth.js/auth.ts and paste following code inside it
```javascript
import NextAuth from "next-auth"
import GitHub from "next-auth/providers/github"

export const {
  handlers: { GET, POST },
  auth,
} = NextAuth({
  providers: [GitHub],
})
```
- Create a file inside app folder as follows
app -> api -> auth -> [...nextauth] -> route.js/route.ts

- Inside the route.js/route.ts file paste the following code.
```javascript
export { GET, POST } from "@/auth"
export const runtime = "edge" // optional
```
- Go to the .env file and create a AUTH_SECRET and paste it.

- Inside the root folder create a new file called middleware.js/middleware.ts. If you misspell the file name it will not work. Paste the following code inside it
```javascript
import { auth } from "./auth"
export default auth((req) => {
  // req.auth
})

// Optionally, don't invoke Middleware on some paths
// Read more: https://nextjs.org/docs/app/building-your-application/routing/middleware#matcher
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
}
```
- The route inside the matcher will invoke the auth function. route inside the matcher is not private route or public route.

- In the above example everything will invoke the auth function except the item mentioned int he matcher array.

- In the matcher you can use following code matcher: ["/((?!.+\\.[\\w]+$|_next).*)", "/", "/(api|trpc)(.*)"]

- With the above matcher, all routes will invoke auth function, with the exception of internal /_next/ routes and static files. Static files are detected by matching on paths that end in .+\..+. Then inside the auth function we can decide which route should be protected and which route should not. 

- One policy for protecting is that initially the whole app will be protected and some route like landing page, documentation etc will be public.


- In the root create a file name route.js/route.ts and paste following code.
```javascript
/**
 * An array of routes that are accessible to the public
 * These routes do not require authentication
 * @type {string[]}
 */
export const publicRoutes = [
  "/",
  "/auth/new-verification"
];

/**
 * An array of routes that are used for authentication
 * These routes will redirect logged in users to /settings
 * @type {string[]}
 */
export const authRoutes = [
  "/auth/login",
  "/auth/register",
  "/auth/error",
  "/auth/reset",
  "/auth/new-password"
];

/**
 * The prefix for API authentication routes
 * Routes that start with this prefix are used for API authentication purposes
 * @type {string}
 */
export const apiAuthPrefix = "/api/auth";

/**
 * The default redirect path after logging in
 * @type {string}
 */
export const DEFAULT_LOGIN_REDIRECT = "/settings";
```

- publicRoutes array contains routes that anyone can access without authorization. authRoutes contains routes that are necessary for authorization and logged in user cannot go to these routes. apiAuthPrefix are used for api authentication purpose so must be public. DEFAULT_LOGIN_REDIRECT is the route where user will be redirected after successful logging in. 

- Inside the middleware file the auth function will be as follows

```javascript
export default auth((req) => {
  const { nextUrl } = req;
  const isLoggedIn = !!req.auth;

  const isApiAuthRoute = nextUrl.pathname.startsWith(apiAuthPrefix);
  const isPublicRoute = publicRoutes.includes(nextUrl.pathname);
  const isAuthRoute = authRoutes.includes(nextUrl.pathname);

  if (isApiAuthRoute) {
    return null;
  }

  if (isAuthRoute) {
    if (isLoggedIn) {
      return Response.redirect(new URL(DEFAULT_LOGIN_REDIRECT, nextUrl))
    }
    return null;
  }

  if (!isLoggedIn && !isPublicRoute) {
    return Response.redirect(new URL("/auth/login", nextUrl))
  }

  return null;
})
```

- Above code from req the nextUrl is getting. Then checked whether user is logged in. Then apiAuthRoute, publicRoute, authRoute is created. Then first if condition checked whether user clicked route is apiAuthRoute. If it is then it return null means do nothing and allow user to access the route. Second if condition check whether user is in authRoute. If user is in authRoute then it check whether user is logged in. If user is logged in then it redirect user to the DEFAULT_LOGIN_REDIRECT page otherwise it allow user to visit the page. Third if statement check whether user is not logged in and also user is not in public route. if it is true it redirect user to the login page. If any of the condition is not met that means user is logged in and user in the protected route and it allow user to visit that page. 

### Using callback function to apply role based authentication

- Details is describe in the following link video https://www.youtube.com/watch?v=1MTyCvS05V4&t=18s the time line is 02.50.53 to 03.20.33 min



### Email verification for credential users

- Go to the following youtube link https://www.youtube.com/watch?v=1MTyCvS05V4&t=18s check from 03.47.58 to 4.48.11 min;

### Next js smooth image load

- Check the following Image tag and our focus is last two lines of code.
```javascript
<Image
src={`http://pri....`}
alt="hello"
width={600}
height={400}
className= "transition-opacity opacity-0 duration-[2s]"
onLoadingComplete = {(image) => image.classList.remove("opacity-0")}
/>
```

### Create folder and page simultaneously

- Inside app folder click new file and write the folder name then put / and write the file name. Press enter. 


### Auth related project requirements
- Create login page
- Create register page
- Create mongodb connection
- Create user schema
- Create app bar with signin and signout button
- Create api/auth/[...nextauth] route file
- Create api/register route
- Create middleware function
- Make login and register page functional
- Create session provider
- Create server and client component and pass data to them
- 
