# Stripe Integration in Next.js 14 app router

- Introduction
- Installing stripe in your project
- Create a global context for storing product information
- Wraping the whole application by the CartProvider function
- Design and implement cart page
- Store stripe pk and secret in .env file
- Creating payment page
- Creating CheckoutForm component

### Introduction
- In this blog i will explain with an example how to implement stripe payment process in next.js 14 app router project. 
- We will have three services for which there will be a one-off payment deduction.
- This blog will provide you the minimum features to implement payment process. 
- If you want to learn comprehensively about Stripe this is not suitable for you.
- In the following link you will also find the documentation of implementing stripe in next.js project. https://stripe.com/docs/payments/quickstart

### Installing stripe in your project

- Open the terminal in the vs code and paste the following code.

```javascript
npm install --save stripe @stripe/stripe-js next
```
### Create a global context for storing product information

- Inside the utils folder we created a cart folder and CartContext file. You can name your file as you wish. After creating the file paste the following code.

```javascript
"use client"

import { createContext, useState } from "react"


export const cartContext = createContext()

export const CartProvider =({children}) => {
  const [cart, setCart] = useState([])
  const [price, setPrice] = useState(0)
  console.log(cart)
  return (
    <cartContext.Provider
    value={{cart, setCart, price, setPrice}}
    >
    {children}
    </cartContext.Provider>
  )
}
```
- Context page must be client component so i wrote use client at the top of the component.
 
 - I imported createContext and useState from react.

 - I initialize the createContext hook and put it inside cartContext variable and exported it so that it can be used by other component.

 - Created a CartProvider function and export it. The function takes children as an argument.

 - Inside the function i created two state. cart will be used for storing product name and price will be used for storing product price. You can set state as per your requirement.

 - The function return cartContext tag and cart, setCart, price and setPrice are sent as an object with the name of value props. 


 ### Wrapping the whole application by the CartProvider function

 - Go to the layout.js/layout.ts file inside the app folder. Inside the return wrap the children by CartProvider. It will look likes as follows.

 ```javascript
import { CartProvider } from "@/utils/Cart/CartContext"
import AuthProvider from "@/utils/SessionProvider"

export const metadata = {
  title: 'Next.js',
  description: 'Generated by Next.js',
}

export default function RootLayout({ children }) {
 return (
    <html lang="en">
      <body>
        <AuthProvider>
<CartProvider>
        {children}
</CartProvider>
        </AuthProvider>
        </body>
    </html>
  )
}

 ```

### Design and implement cart page

- Design cart page where all the product information with price will be shown.

```javascript
'use client'
import { cartContext } from '@/utils/Cart/CartContext';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import React, { useContext, useEffect, useState } from 'react'

const Cart = () => {
  const {cart, setPrice, price} = useContext(cartContext)
 
 useEffect(() => {
  if(cart === 'Free'){
    setPrice(10)
  }else if(cart === 'Premium'){
    setPrice(30)
  } else if (cart === "Enterprise"){
    setPrice(50)
  } else {
   setPrice(0)
  }
 },[cart, setPrice])
console.log('cart', cart, price)
  return (
    <div>
      <h1>Cart Page</h1>
      <p>Product Name: {cart}</p>
    <p>Price: ${price}</p>
    {
      cart.length ? 
    <Link href={'/payment'}>
    <button 
     className='btn bg-purple-300 hover:bg-purple-500'>Pay</button>
    </Link> : <button 
    disabled={!cart.length}
    className='btn '>Pay</button>
    }
    </div>
  );
}

export default Cart
```

- I used hooks inside the component so made it client component by writing use client at the top of the component.

- useContext hook is called to get states from context. 
- useEffect hook is used to set the price based on the services button clicked by the user. 
- Inside the return service name that customer selected and it's price is shown dynamically. 
- If there is any item in the cart then a pay button will appear an on clicking it user will be redirected to the payment page. If there is nothing inside the cart state then only pay button will show but it will be disable. 

### Store stripe pk and secret in .env file
- Open the .env file and paste following two lines.
```javascript
NEXT_PAYMENT_GATEWAY_PUBLIC_KEY=
NEXT_PAYMENT_SECRET_KEY=
```

- Now go to the stripe.com and sign in your account. Click API keys for developers tab. Copy the Publishable Key and Secret Key and paste them in the .env file.

### Creating payment page

- Go to the app folder. Inside it create a folder name payment and inside that create file name page.js/page.ts/page.jsx/page.tsx. Paste the following code inside the file.
```javascript
"use client";
import CheckoutForm from "@/components/CheckoutFrom/CheckoutForm";
import { Elements } from "@stripe/react-stripe-js";
import { loadStripe } from "@stripe/stripe-js";

const stripePromise = loadStripe(process.env.NEXT_PUBLIC_PAYMENT_GATEWAY_PK);

const Payment = () => {
  return (
      <Elements stripe={stripePromise}>
        <CheckoutForm />
      </Elements>
  );
};

export default Payment;

```
- This a client component so wrote use client at the top of the page. 

- Elements and loadStripe are imported from stripe. 

- A stripeProvide variable is created that initialize loadStripe function that we imported from stripe. It takes stripe publishable key from .env file

- Inside the return Elements component wraps the CheckoutForm component. 

- In the element component stripe props is passed that contains stripePromise that we declared earlier. 

### Creating CheckoutForm component

- Create a file with the name of CheckoutForm and paste the following code.

```javascript
"use client";

import { cartContext } from "@/utils/Cart/CartContext";
import { CardElement, useElements, useStripe } from "@stripe/react-stripe-js";
import { useContext, useEffect, useState } from "react";

const CheckoutForm = () => {
  const [error, setError] = useState("");
  const elements = useElements();
  const [clientSecret, setClientSecret] = useState("");
  const [transactionId, setTransactionId] = useState("");
  const stripe = useStripe();
  const { cart, price } = useContext(cartContext);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const res = await fetch("/api/create-payment-intent", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ price }),
        });

        if (!res.ok) {
          throw new Error(`Failed to fetch data. Status: ${res.status}`);
        }

        const data = await res.json();
        console.log("Data", data);

        setClientSecret(data.secret);
      } catch (error) {
        console.error("Error fetching data:", error.message);
      }
    };

    fetchData();
  }, [price]);

  console.log(clientSecret);
  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!stripe || !elements) {
      return;
    }

    const card = elements.getElement(CardElement);

    if (card === null) {
      return;
    }

    const { error, paymentMethod } = await stripe.createPaymentMethod({
      type: "card",
      card,
    });

    if (error) {
      console.log("Payment error", error);
      setError(error.message);
    } else {
      console.log("Payment method", paymentMethod);
      setError("");
    }

    const { paymentIntent, error: confirmError } =
      await stripe.confirmCardPayment(clientSecret, {
        payment_method: {
          card: card,
        },
      });

    if (confirmError) {
      console.log(confirmError);
    } else {
      console.log("payment intent", paymentIntent);
      if (paymentIntent.status === "succeeded") {
        setTransactionId(paymentIntent.id);
      }
    }
  };
  return (
    <form onSubmit={handleSubmit}>
      <CardElement
        options={{
          style: {
            base: {
              fontSize: "16px",
              color: "#424770",
              "::placeholder": {
                color: "#aab7c4",
              },
            },
            invalid: {
              color: "#9e2146",
            },
          },
        }}
      />

      <button
        className=" btn bg-purple-400 hover:bg-purple-600"
        type="submit"
        disabled={!stripe || !clientSecret}
      >
        Pay
      </button>
      <p className="text-red-500">{error}</p>
      {transactionId && (
        <p className="text-green-600">Your transaction id: {transactionId}</p>
      )}
    </form>
  );
};

export default CheckoutForm;

```

- It is a client component so use client was written at the top of the component.

- cartContext is imported at top. 

- CardElement, useElements and useStripe imported from stripe.

- useContext, useEffect, useState hook is imported from react.

- error state is created to  store error message if any error occurred during the payment process.

- clientSecret state is created to stored client secret which will be received from the server.

- transactionId state is created to store transaction id after successful payment.

- useElements and useStripe are initialize and store inside elements and stripe variable respectively.

- From the context cart and price values are destructured. 

- useEffect hook is used to call api and get client secret from backend.

- fetch data is an asynchronous function. 

- The res variable storeS the result obtain from api call. fetch is used to post data to the backend. The /api/create-payment-intent route is called and price of the service is sent to the backend. 

- If ok result is not found inside the res variable then it will throw new error.

- data variable store the result obtained from res variable. 

- The secret property of data object is set to the clientSecret state.

- If any error occurred during the post process then it is catch by catch block and shown in the console. You can show toast instead. 

- fetchData is called inside the useEffect hook.

- price is set as a dependency of useEffect hook.

- The handleSubmit is an asynchronous function that takes event from the form and initially prevent the default behavior. 

- It then check whether stripe and elements does not have any value. If any one does not have any value then it return from here because without them the processing of payment will not be possible. 

- From the elements the cardElement is get and store inside the card variable. It will be used in the later stage. You can directly use the cardElement instead of storing it inside card variable. 

- If the value of card variable (that means cardElement) is null then it will return from here. 

- stripe.createPaymentMethod({ type: "card", card }): This line of code is using the createPaymentMethod method provided by the stripe object. It creates a payment method, specifically of type "card", using the card information provided. You can put other information like user name, email etc inside this object.

- type: "card": Specifies that the payment method being created is a card.

- card: This is the card variable that contains CardElement that will be used for the payment.

- await stripe.createPaymentMethod(...): The await keyword is used here because the createPaymentMethod method likely returns a Promise. This ensures that the next lines of code will only execute after the payment method creation process is complete.

- const { error, paymentMethod }: The result of the createPaymentMethod operation is destructured into two variables - error and paymentMethod.

- error: If there is any error during the payment method creation, it will be stored in the error variable.

- paymentMethod: If the creation is successful, the payment method details will be stored in the paymentMethod variable.

- Then if and else block is used. If there is any error occurred then it will set the error in the error state. Otherwise it will show paymentMethod in the console. Here error state also cleared. 

- stripe.confirmCardPayment(clientSecret, { payment_method: { card: card } }): This line of code is using the confirmCardPayment method provided by the stripe object. It attempts to confirm a payment using a card and a client secret.

- clientSecret: This is the secret key associated with a payment, obtained from the server.

- payment_method: { card: card }: Specifies the payment method to be used for confirmation, and in this case, it is a card.

- await stripe.confirmCardPayment(...): The await keyword is used here because the confirmCardPayment method likely returns a Promise. This ensures that the next lines of code will only execute after the confirmation process is complete.

- const { paymentIntent, error: confirmError }: The result of the confirmCardPayment operation is destructured into two variables - paymentIntent and confirmError.

- paymentIntent: If the confirmation is successful, the payment intent details will be stored in the paymentIntent variable.

- error: confirmError: If there is any error during the confirmation process, it will be stored in the confirmError variable.

- Then if and else block is used. If there is any error occurred then it will be stored inside confirmError and shown in the console. You can show toast or alert also. Otherwise it will show paymentIntent in the console. Here another if condition applied. If the status of paymentIntent is succeeded then the id is stored inside the transactionId state. You can redirect the user to the success page or show toast or alert. 

- Inside the return a form is created and handleSubmit function is set as onSubmit handler.

- Inside the form CardElement is used that we imported from stripe. 

- CardElement takes options as props that is used to design the form. You can add other features to the design. 

- Inside the form there is a button named pay. If there is no clientSecret or nothing inside the stripe variable then the button will be disabled.

- For showing error message a p tag is used inside the form. 

- Another p tag will be conditionally shown if there is any value inside transactionId state. 

### Create backend route for payment processing

- Go to the api folder inside the app folder. Create a new folder inside the api folder and name it create-payment-intent and create file name route.js/route.ts inside it. Paste following code inside the file.

```javascript
import { NextResponse } from "next/server";

const stripe = require("stripe")(process.env.NEXT_PAYMENT_SECRET_KEY);

export const POST = async (request) => {
  try {
    const { price } = await request.json();
    console.log(price);
    const amount = parseInt(price * 100);

    const paymentIntent = await stripe.paymentIntents.create({
      amount: amount,
      currency: "usd",
      payment_method_types: ["card"],
    });

    console.log(paymentIntent);

    // Correct the response format
    return NextResponse.json(
      { secret: paymentIntent.client_secret },
      { status: 200 }
    );
  } catch (error) {
    console.error("Error processing payment intent:", error);
    return NextResponse.error(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
};

```

- NextResponse is imported from next/server

- stripe variable import stripe and pass the stripe secret key from .env file to it. 

- A post asynchronous function is created that takes request as a parameter. 

- Inside the try block the price is destructured from request object. 

- amount variable store the converted price in cents. 

- stripe.paymentIntents.create(...): This line of code is using the create method provided by the paymentIntents object of the stripe API. It creates a new PaymentIntent, which is a representation of an intent to collect payment from a customer.

- amount: Specifies the amount of the payment.
currency: "usd": Sets the currency for the payment, in this case, US dollars.

- payment_method_types: ["card"]: Specifies that the payment method to be used is of type card.

- await stripe.paymentIntents.create(...): The await keyword is used here because the create method likely returns a Promise. This ensures that the next lines of code will only execute after the creation process is complete.

- const paymentIntent: The result of the create operation, which is the newly created PaymentIntent, is stored in the paymentIntent variable.

- The client_secret property of paymentIntent is send to the frontend.

- The catch block catch the error in the process and console it and send the error to the frontend. 

### Check the stripe account to confirm that the payment is collected from the client.

- Go to the website and make a purchase. 

- If the purchase is successful then go to the stripe dashboard. Then go to the payment tab and inside that go to the All payments tab. Match the payment shown in the tab together with the transactionId with the frontend data to make sure that the payment indeed collected.